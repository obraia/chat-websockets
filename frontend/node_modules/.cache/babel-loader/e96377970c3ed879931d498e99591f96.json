{"ast":null,"code":"var _jsxFileName = \"/home/bryan/Programa\\xE7\\xE3o/WebDev/Portifolio - Bryan Diniz/web/src/pages/Projects/Chat/Description/index.js\";\nimport React, { useState, useContext } from 'react';\nimport { ThemeContext } from 'styled-components';\nimport screenshotDark from './img/screenshot-dark.png';\nimport screenshotLight from './img/screenshot-light.png';\nimport { Link } from 'react-router-dom';\nimport { Project, ProjectTitle, ProjectDescription, ProjectContainer, CodeBlock } from './styles';\n\nfunction ChatDescription() {\n  const {\n    title: theme\n  } = useContext(ThemeContext);\n\n  function newTab(url) {\n    window.open(url, '_blank');\n  }\n\n  return React.createElement(Project, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 21\n    },\n    __self: this\n  }, React.createElement(ProjectTitle, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 23\n    },\n    __self: this\n  }, \"Chat com websockets \", React.createElement(\"button\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 24\n    },\n    __self: this\n  }, React.createElement(Link, {\n    to: '/projects/chat',\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 24\n    },\n    __self: this\n  }, \"Testar\"))), React.createElement(ProjectDescription, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 27\n    },\n    __self: this\n  }, \"Projeto de um chat em tempo real feito utilizando Node, Express e React com a biblioteca\", React.createElement(\"a\", {\n    onClick: () => newTab('https://socket.io/get-started/chat/'),\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 29\n    },\n    __self: this\n  }, \" socket.io \"), \" tanto no Client-Side quanto no Server-side. O backend e o frontend s\\xE3o relativamente simples, como podemos ver abaixo:\"), React.createElement(ProjectContainer, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 33\n    },\n    __self: this\n  }, React.createElement(CodeBlock, {\n    className: \"line-numbers language-javascript\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 34\n    },\n    __self: this\n  }, React.createElement(\"h3\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 35\n    },\n    __self: this\n  }, \"Backend NodeJS\"), React.createElement(\"code\", {\n    className: \"language-javascript\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 37\n    },\n    __self: this\n  }, `const express = require('express');\nconst http = require('http');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = require('socket.io').listen(server);\n\nlet messageId = 0;\n\nio.on('connection', socket => {\n    console.log('Socket conectado ' + socket.id);\n\n    socket.on('sendMessage', data => {\n        data.id = messageId++;\n        socket.broadcast.emit('recivedMessage', data);\n        console.log(data);\n    });\n});\n\nserver.listen(process.env.PORT || 3333);`, \" \")), theme == 'light' ? React.createElement(\"img\", {\n    src: screenshotLight,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 63\n    },\n    __self: this\n  }) : React.createElement(\"img\", {\n    src: screenshotDark,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 63\n    },\n    __self: this\n  })), React.createElement(ProjectDescription, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 67\n    },\n    __self: this\n  }, \"A comunica\\xE7\\xE3o do frontend com o backend \\xE9 feito com o\", React.createElement(\"a\", {\n    onClick: () => newTab('https://www.npmjs.com/package/socket.io-client'),\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 69\n    },\n    __self: this\n  }, \" socket.io-client \"), \"atrav\\xE9s de um script de poucas linhas:\"), React.createElement(ProjectContainer, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 73\n    },\n    __self: this\n  }, React.createElement(CodeBlock, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 74\n    },\n    __self: this\n  }, React.createElement(\"h3\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 75\n    },\n    __self: this\n  }, \"Script socket.js (ReactJS)\"), React.createElement(\"code\", {\n    className: \"language-javascript\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 77\n    },\n    __self: this\n  }, `import io from \"socket.io-client\";\n\nconst socket = io(process.env.REACT_APP_CHATAPP || 'https://BACKEND-URL.com', {});\nsocket.on('connect', () => { console.log('[IO] Connect => Connection established') });\n\nexport default socket;`, \" \"))), React.createElement(ProjectDescription, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 90\n    },\n    __self: this\n  }, \"Para enviar as mensagens, temos na fun\\xE7\\xE3o handleSubmit o socket.emit() que \\xE9 usado para enviar promises para o backend. Essa fun\\xE7\\xE3o recebe dois par\\xE2metros, o nome da promise e o objeto JSON a ser enviado.\"), React.createElement(ProjectContainer, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 95\n    },\n    __self: this\n  }, React.createElement(CodeBlock, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 96\n    },\n    __self: this\n  }, React.createElement(\"h3\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 97\n    },\n    __self: this\n  }, \"Componente principal (ReactJS)\"), React.createElement(\"code\", {\n    className: \"language-javascript\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 99\n    },\n    __self: this\n  }, `import React, { useState, useEffect, useRef, useMemo } from 'react';\nimport { lighten, desaturate, getContrast } from \"polished\";\n\nimport socket from \"../../../../services/socket\";\n\nimport { Container, MessageContainer, Message, MessageUser, MessageText, MessageDate, \n    InputGroup, InputText, LabelInput, InputMessage, SendButtonInput } from './styles';\n\nfunction Chat() {\n    const [messages, setMessages] = useState([]);\n    const [recivedMessage, setRecivedMessage] = useState(null);\n    const [messageID, setMessageID] = useState(0);\n    const [messageColor, setMessageColor] = useState('');\n    const [textColor, setTextColor] = useState('');\n\n    const messageText = useRef();\n    const username = useRef();\n\n    useMemo(() => {\n        socket.on('recivedMessage', message => {\n            message.from = 'others';\n            setRecivedMessage(message);\n            console.log(message);\n        })\n    }, []);\n\n    useEffect(() => {\n        if (recivedMessage) setMessages([...messages, recivedMessage]);\n    }, [recivedMessage]);\n\n    useEffect(() => {\n        getRandomColor();\n    }, []);\n\n    function getRandomColor() {\n        let backgroundColor = '#' + (0x1000000 + (Math.random()) * 0xffffff).toString(16).substr(1, 6)\n        backgroundColor = desaturate(0.2, (lighten(0.2, backgroundColor)));\n\n        let textColor = getConstrastColor(backgroundColor);\n\n        setMessageColor(backgroundColor);\n        setTextColor(textColor);\n    }\n\n    function getConstrastColor(color) {\n        if (getContrast(color, '#fff') < 5.0) return '#3d3d3d';\n        else return '#dedede';\n    }\n\n    async function handleSubmit(event) {\n        event.preventDefault();\n\n        setMessageID(messageID - 1);\n\n        const date = new Date().toTimeString().replace(/.*(\\d{2}:\\d{2}:).*/, \"$1\").slice(0, -1);\n\n        const newMessage = {\n            from: 'my',\n            id: messageID,\n            username: username.current.value,\n            text: messageText.current.value,\n            backgroundColor: messageColor,\n            textColor: textColor,\n            date,\n        }\n\n        setMessages([...messages, newMessage]);\n\n        socket.emit('sendMessage', newMessage);\n\n        messageText.current.value = '';\n    }\n\n    return (\n        <Container autoComplete=\"off\" onSubmit={handleSubmit}>\n\n            <InputGroup>\n                <LabelInput htmlFor=\"username\">Username</LabelInput>\n\n                <InputText\n                    id=\"username\"\n                    ref={username}\n                    required />\n            </InputGroup>\n\n            <MessageContainer id=\"messageContainer\">\n\n                {messages.map(m => (\n                    <Message className={m.from} key={m.id}\n                        style={{ background: m.backgroundColor }}>\n                        <MessageText style={{ color: m.textColor }}>\n                            <MessageUser>{m.username}:</MessageUser>\n                            {m.text}\n                        </MessageText>\n                        <MessageDate>{m.date}</MessageDate>\n                    </Message>\n                ))}\n\n            </MessageContainer>\n\n            <InputGroup>\n                <InputMessage\n                    id=\"message\"\n                    placeholder=\"Enviar mensagem...\"\n                    ref={messageText}\n                    required />\n\n                <SendButtonInput>Enviar</SendButtonInput>\n            </InputGroup>\n\n        </Container>\n    );\n}\n\nexport default Chat;`, \" \"))), React.createElement(ProjectDescription, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 221\n    },\n    __self: this\n  }, \"Agora para receber uma mensagem do backend temos a a fun\\xE7\\xE3o socket.on() que ficar\\xE1 \\\"escultando\\\" o servidor at\\xE9 ele enviar uma promise do tipo 'recivedMessage' no nosso caso. O uso do useMemo em conjunto com o useEffect foi uma solu\\xE7\\xE3o que encontrei para corrigir um problema estranho que tive, esse problema pode ser visto no seguinte\", React.createElement(\"a\", {\n    onClick: () => newTab('https://youtu.be/5427pRmQ8Oo'),\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 226\n    },\n    __self: this\n  }, \" v\\xEDdeo\"), \".\"), React.createElement(ProjectDescription, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 229\n    },\n    __self: this\n  }, \"O c\\xF3digo completo pode ser encontrado no meu reposit\\xF3rio do github\", React.createElement(\"a\", {\n    onClick: () => newTab('https://github.com/obraia'),\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 231\n    },\n    __self: this\n  }, \" clicando aqui\"), \".\"));\n}\n\nexport default ChatDescription;","map":{"version":3,"sources":["/home/bryan/Programação/WebDev/Portifolio - Bryan Diniz/web/src/pages/Projects/Chat/Description/index.js"],"names":["React","useState","useContext","ThemeContext","screenshotDark","screenshotLight","Link","Project","ProjectTitle","ProjectDescription","ProjectContainer","CodeBlock","ChatDescription","title","theme","newTab","url","window","open"],"mappings":"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","sourcesContent":["import React, { useState, useContext } from 'react';\nimport { ThemeContext } from 'styled-components';\n\nimport screenshotDark from './img/screenshot-dark.png';\nimport screenshotLight from './img/screenshot-light.png';\n\nimport { Link } from 'react-router-dom';\n\nimport { Project, ProjectTitle, ProjectDescription, ProjectContainer, CodeBlock } from './styles';\n\nfunction ChatDescription() {\n\n    const { title: theme } = useContext(ThemeContext);\n\n    function newTab(url) {\n        window.open(url, '_blank');\n    }\n\n    return (\n\n        <Project>\n\n            <ProjectTitle>\n                Chat com websockets <button><Link to={'/projects/chat'}>Testar</Link></button>\n            </ProjectTitle>\n\n            <ProjectDescription>\n                Projeto de um chat em tempo real feito utilizando Node, Express e React com a biblioteca\n                <a onClick={() => newTab('https://socket.io/get-started/chat/')}> socket.io </a> tanto no Client-Side\n                quanto no Server-side. O backend e o frontend são relativamente simples, como podemos ver abaixo:\n                </ProjectDescription>\n\n            <ProjectContainer>\n                <CodeBlock className=\"line-numbers language-javascript\">\n                    <h3>Backend NodeJS</h3>\n\n                    <code className=\"language-javascript\">\n                        {\n                            `const express = require('express');\nconst http = require('http');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = require('socket.io').listen(server);\n\nlet messageId = 0;\n\nio.on('connection', socket => {\n    console.log('Socket conectado ' + socket.id);\n\n    socket.on('sendMessage', data => {\n        data.id = messageId++;\n        socket.broadcast.emit('recivedMessage', data);\n        console.log(data);\n    });\n});\n\nserver.listen(process.env.PORT || 3333);`\n                        } </code>\n\n                </CodeBlock>\n\n                {theme == 'light' ? <img src={screenshotLight} /> : <img src={screenshotDark} />}\n\n            </ProjectContainer>\n\n            <ProjectDescription>\n                A comunicação do frontend com o backend é feito com o\n                    <a onClick={() => newTab('https://www.npmjs.com/package/socket.io-client')}> socket.io-client </a>\n                através de um script de poucas linhas:\n            </ProjectDescription>\n\n            <ProjectContainer>\n                <CodeBlock>\n                    <h3>Script socket.js (ReactJS)</h3>\n\n                    <code className=\"language-javascript\">\n                        {\n                            `import io from \"socket.io-client\";\n\nconst socket = io(process.env.REACT_APP_CHATAPP || 'https://BACKEND-URL.com', {});\nsocket.on('connect', () => { console.log('[IO] Connect => Connection established') });\n\nexport default socket;`\n                        } </code>\n\n                </CodeBlock>\n            </ProjectContainer>\n\n            <ProjectDescription>\n                Para enviar as mensagens, temos na função handleSubmit o socket.emit() que é usado para enviar promises\n                para o backend. Essa função recebe dois parâmetros, o nome da promise e o objeto JSON a ser enviado.\n            </ProjectDescription>\n\n            <ProjectContainer>\n                <CodeBlock>\n                    <h3>Componente principal (ReactJS)</h3>\n\n                    <code className=\"language-javascript\">\n                        {\n`import React, { useState, useEffect, useRef, useMemo } from 'react';\nimport { lighten, desaturate, getContrast } from \"polished\";\n\nimport socket from \"../../../../services/socket\";\n\nimport { Container, MessageContainer, Message, MessageUser, MessageText, MessageDate, \n    InputGroup, InputText, LabelInput, InputMessage, SendButtonInput } from './styles';\n\nfunction Chat() {\n    const [messages, setMessages] = useState([]);\n    const [recivedMessage, setRecivedMessage] = useState(null);\n    const [messageID, setMessageID] = useState(0);\n    const [messageColor, setMessageColor] = useState('');\n    const [textColor, setTextColor] = useState('');\n\n    const messageText = useRef();\n    const username = useRef();\n\n    useMemo(() => {\n        socket.on('recivedMessage', message => {\n            message.from = 'others';\n            setRecivedMessage(message);\n            console.log(message);\n        })\n    }, []);\n\n    useEffect(() => {\n        if (recivedMessage) setMessages([...messages, recivedMessage]);\n    }, [recivedMessage]);\n\n    useEffect(() => {\n        getRandomColor();\n    }, []);\n\n    function getRandomColor() {\n        let backgroundColor = '#' + (0x1000000 + (Math.random()) * 0xffffff).toString(16).substr(1, 6)\n        backgroundColor = desaturate(0.2, (lighten(0.2, backgroundColor)));\n\n        let textColor = getConstrastColor(backgroundColor);\n\n        setMessageColor(backgroundColor);\n        setTextColor(textColor);\n    }\n\n    function getConstrastColor(color) {\n        if (getContrast(color, '#fff') < 5.0) return '#3d3d3d';\n        else return '#dedede';\n    }\n\n    async function handleSubmit(event) {\n        event.preventDefault();\n\n        setMessageID(messageID - 1);\n\n        const date = new Date().toTimeString().replace(/.*(\\d{2}:\\d{2}:).*/, \"$1\").slice(0, -1);\n\n        const newMessage = {\n            from: 'my',\n            id: messageID,\n            username: username.current.value,\n            text: messageText.current.value,\n            backgroundColor: messageColor,\n            textColor: textColor,\n            date,\n        }\n\n        setMessages([...messages, newMessage]);\n\n        socket.emit('sendMessage', newMessage);\n\n        messageText.current.value = '';\n    }\n\n    return (\n        <Container autoComplete=\"off\" onSubmit={handleSubmit}>\n\n            <InputGroup>\n                <LabelInput htmlFor=\"username\">Username</LabelInput>\n\n                <InputText\n                    id=\"username\"\n                    ref={username}\n                    required />\n            </InputGroup>\n\n            <MessageContainer id=\"messageContainer\">\n\n                {messages.map(m => (\n                    <Message className={m.from} key={m.id}\n                        style={{ background: m.backgroundColor }}>\n                        <MessageText style={{ color: m.textColor }}>\n                            <MessageUser>{m.username}:</MessageUser>\n                            {m.text}\n                        </MessageText>\n                        <MessageDate>{m.date}</MessageDate>\n                    </Message>\n                ))}\n\n            </MessageContainer>\n\n            <InputGroup>\n                <InputMessage\n                    id=\"message\"\n                    placeholder=\"Enviar mensagem...\"\n                    ref={messageText}\n                    required />\n\n                <SendButtonInput>Enviar</SendButtonInput>\n            </InputGroup>\n\n        </Container>\n    );\n}\n\nexport default Chat;`\n                        } </code>\n\n                </CodeBlock>\n            </ProjectContainer>\n\n            <ProjectDescription>\n                Agora para receber uma mensagem do backend temos a a função socket.on() que ficará\n                \"escultando\" o servidor até ele enviar uma promise do tipo 'recivedMessage' no nosso caso. O uso do\n                useMemo em conjunto com o useEffect foi uma solução que encontrei para corrigir um problema\n                estranho que tive, esse problema pode ser visto no seguinte\n                <a onClick={() => newTab('https://youtu.be/5427pRmQ8Oo')}> vídeo</a>.\n            </ProjectDescription>\n\n            <ProjectDescription>\n                O código completo pode ser encontrado no meu repositório do github\n                    <a onClick={() => newTab('https://github.com/obraia')}> clicando aqui</a>.\n            </ProjectDescription>\n\n        </Project>\n    );\n}\n\nexport default ChatDescription;"]},"metadata":{},"sourceType":"module"}