{"ast":null,"code":"var _jsxFileName = \"/home/bryan/Programa\\xE7\\xE3o/WebDev/Portifolio - Bryan Diniz/web/src/pages/Projects/Chat/Description/index.js\";\nimport React from 'react';\nimport screenshot from './img/screenshot.jpg';\nimport screenshotDark from './img/screenshot-dark.jpg';\nimport screenshotLight from './img/screenshot-light.jpg';\nimport { Link } from 'react-router-dom';\nimport { Project, ProjectTitle, ProjectDescription, ProjectContainer, CodeBlock } from './styles';\n\nfunction ChatDescription() {\n  function newTab(url) {\n    window.open(url, '_blank');\n  }\n\n  return React.createElement(Project, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 18\n    },\n    __self: this\n  }, React.createElement(Link, {\n    to: '/projects/chat',\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 19\n    },\n    __self: this\n  }, React.createElement(ProjectTitle, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 20\n    },\n    __self: this\n  }, \"\\xBB Chat com websockets (Testar)\")), React.createElement(ProjectDescription, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 23\n    },\n    __self: this\n  }, \"Projeto de um chat em tempo real feito utilizando Node, Express e React com a biblioteca\", React.createElement(\"a\", {\n    onClick: () => newTab('https://socket.io/get-started/chat/'),\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 25\n    },\n    __self: this\n  }, \" socket.io \"), \" tanto no Client-Side quanto no Server-side. O backend e o frontend s\\xE3o relativamente simples, como podemos ver abaixo:\"), React.createElement(ProjectContainer, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 29\n    },\n    __self: this\n  }, React.createElement(CodeBlock, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 30\n    },\n    __self: this\n  }, React.createElement(\"h3\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 31\n    },\n    __self: this\n  }, \"Backend NodeJS\"), React.createElement(\"code\", {\n    className: \"language-javascript\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 33\n    },\n    __self: this\n  }, `const express = require('express');\nconst http = require('http');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = require('socket.io').listen(server);\n\nlet messageId = 0;\n\nio.on('connection', socket => {\n    console.log('Socket conectado ' + socket.id);\n\n    socket.on('sendMessage', data => {\n        data.id = messageId++;\n        socket.broadcast.emit('recivedMessage', data);\n        console.log(data);\n    });\n});\n\nserver.listen(process.env.PORT || 3333);`, \" \")), React.createElement(\"img\", {\n    src: screenshotDark,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 58\n    },\n    __self: this\n  })), React.createElement(ProjectDescription, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 62\n    },\n    __self: this\n  }, \"A comunica\\xE7\\xE3o do frontend com o backend \\xE9 feito com o\", React.createElement(\"a\", {\n    onClick: () => newTab('https://www.npmjs.com/package/socket.io-client'),\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 64\n    },\n    __self: this\n  }, \" socket.io-client \"), \"atrav\\xE9s de um script de poucas linhas:\"), React.createElement(ProjectContainer, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 68\n    },\n    __self: this\n  }, React.createElement(CodeBlock, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 69\n    },\n    __self: this\n  }, React.createElement(\"h3\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 70\n    },\n    __self: this\n  }, \"Script socket.js (ReactJS)\"), React.createElement(\"code\", {\n    className: \"language-javascript\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 72\n    },\n    __self: this\n  }, `import io from \"socket.io-client\";\n\nconst socket = io(process.env.REACT_APP_CHATAPP || 'https://BACKEND-URL.com', {});\nsocket.on('connect', () => { console.log('[IO] Connect => Connection established') });\n\nexport default socket;`, \" \"))), React.createElement(ProjectDescription, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 85\n    },\n    __self: this\n  }, \"Para enviar as mensagens, temos na fun\\xE7\\xE3o handleSubmit o socket.emit() que \\xE9 usado para enviar promises para o backend. Essa fun\\xE7\\xE3o recebe dois par\\xE2metros, o nome da promise e o objeto JSON a ser enviado.\"), React.createElement(ProjectContainer, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 90\n    },\n    __self: this\n  }, React.createElement(CodeBlock, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 91\n    },\n    __self: this\n  }, React.createElement(\"h3\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 92\n    },\n    __self: this\n  }, \"Componente principal (ReactJS)\"), React.createElement(\"code\", {\n    className: \"language-javascript\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 94\n    },\n    __self: this\n  }, `import React, { useState, useEffect, useRef, useMemo } from 'react';\n\nimport socket from \"../../../../services/socket\";\n\nfunction Chat() {\n    const [messages, setMessages] = useState([]);\n    const [recivedMessage, setRecivedMessage] = useState(null);\n    \n    const messageText = useRef();\n    const username = useRef();\n\n    useMemo(() => { \n        socket.on('recivedMessage', message => {\n            message.from = 'other';\n            setRecivedMessage(message);\n            console.log(message);\n        })\n    }, []);\n\n    useEffect(()=> {\n        if(recivedMessage) setMessages([...messages, recivedMessage]);\n    },[recivedMessage]);\n\n    function handleSubmit(event) {\n        event.preventDefault();\n\n        const date = new Date().toTimeString().replace(/.*(\\d{2}:\\d{2}:\\d{2}).*/, \"$1\");;\n\n        const newMessage = {\n            from: 'my',\n            id: 0,\n            username: username.current.value,\n            messageText: messageText.current.value,\n            date,\n        }\n\n        setMessages([...messages, newMessage]);\n\n        socket.emit('sendMessage', newMessage);\n\n        messageText.current.value = '';\n    }\n\n    return (\n        ...\n    );\n}\n\nexport default Chat;`, \" \"))), React.createElement(ProjectDescription, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 150\n    },\n    __self: this\n  }, \"Agora para receber uma mensagem do backend temos a a fun\\xE7\\xE3o socket.on() que ficar\\xE1 \\\"escultando\\\" o servidor at\\xE9 ele enviar uma promise do tipo 'recivedMessage' no nosso caso. O uso do useMemo em conjunto com o useEffect foi uma solu\\xE7\\xE3o que encontrei para corrigir um problema estranho que tive, esse problema pode ser visto no seguinte\", React.createElement(\"a\", {\n    onClick: () => newTab('https://youtu.be/5427pRmQ8Oo'),\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 155\n    },\n    __self: this\n  }, \" v\\xEDdeo\"), \".\"), React.createElement(ProjectDescription, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 158\n    },\n    __self: this\n  }, \"O c\\xF3digo completo pode ser encontrado no meu reposit\\xF3rio do github\", React.createElement(\"a\", {\n    onClick: () => newTab('https://github.com/obraia'),\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 160\n    },\n    __self: this\n  }, \" clicando aqui\"), \".\"));\n}\n\nexport default ChatDescription;","map":{"version":3,"sources":["/home/bryan/Programação/WebDev/Portifolio - Bryan Diniz/web/src/pages/Projects/Chat/Description/index.js"],"names":["React","screenshot","screenshotDark","screenshotLight","Link","Project","ProjectTitle","ProjectDescription","ProjectContainer","CodeBlock","ChatDescription","newTab","url","window","open"],"mappings":";AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,UAAP,MAAuB,sBAAvB;AACA,OAAOC,cAAP,MAA2B,2BAA3B;AACA,OAAOC,eAAP,MAA4B,4BAA5B;AAEA,SAASC,IAAT,QAAqB,kBAArB;AAEA,SAASC,OAAT,EAAkBC,YAAlB,EAAgCC,kBAAhC,EAAoDC,gBAApD,EAAsEC,SAAtE,QAAuF,UAAvF;;AAEA,SAASC,eAAT,GAA2B;AAEvB,WAASC,MAAT,CAAgBC,GAAhB,EAAqB;AACjBC,IAAAA,MAAM,CAACC,IAAP,CAAYF,GAAZ,EAAiB,QAAjB;AACH;;AAED,SAEI,oBAAC,OAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KACI,oBAAC,IAAD;AAAM,IAAA,EAAE,EAAE,gBAAV;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KACI,oBAAC,YAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yCADJ,CADJ,EAKI,oBAAC,kBAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iGAEI;AAAG,IAAA,OAAO,EAAE,MAAMD,MAAM,CAAC,qCAAD,CAAxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAFJ,+HALJ,EAWI,oBAAC,gBAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KACI,oBAAC,SAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KACI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBADJ,EAGI;AAAM,IAAA,SAAS,EAAC,qBAAhB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAES;;;;;;;;;;;;;;;;;;;yCAFT,MAHJ,CADJ,EA6BI;AAAK,IAAA,GAAG,EAAET,cAAV;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IA7BJ,CAXJ,EA4CI,oBAAC,kBAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uEAEQ;AAAG,IAAA,OAAO,EAAE,MAAMS,MAAM,CAAC,gDAAD,CAAxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,0BAFR,8CA5CJ,EAkDI,oBAAC,gBAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KACI,oBAAC,SAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KACI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kCADJ,EAGI;AAAM,IAAA,SAAS,EAAC,qBAAhB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAES;;;;;uBAFT,MAHJ,CADJ,CAlDJ,EAmEI,oBAAC,kBAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sOAnEJ,EAwEI,oBAAC,gBAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KACI,oBAAC,SAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KACI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sCADJ,EAGI;AAAM,IAAA,SAAS,EAAC,qBAAhB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAES;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qBAFT,MAHJ,CADJ,CAxEJ,EAoII,oBAAC,kBAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2WAKI;AAAG,IAAA,OAAO,EAAE,MAAMA,MAAM,CAAC,8BAAD,CAAxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iBALJ,MApIJ,EA4II,oBAAC,kBAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iFAEQ;AAAG,IAAA,OAAO,EAAE,MAAMA,MAAM,CAAC,2BAAD,CAAxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBAFR,MA5IJ,CAFJ;AAqJH;;AAED,eAAeD,eAAf","sourcesContent":["import React from 'react';\nimport screenshot from './img/screenshot.jpg';\nimport screenshotDark from './img/screenshot-dark.jpg';\nimport screenshotLight from './img/screenshot-light.jpg';\n\nimport { Link } from 'react-router-dom';\n\nimport { Project, ProjectTitle, ProjectDescription, ProjectContainer, CodeBlock } from './styles';\n\nfunction ChatDescription() {\n\n    function newTab(url) {\n        window.open(url, '_blank');\n    }\n\n    return (\n\n        <Project>\n            <Link to={'/projects/chat'}>\n                <ProjectTitle>» Chat com websockets (Testar)</ProjectTitle>\n            </Link>\n\n            <ProjectDescription>\n                Projeto de um chat em tempo real feito utilizando Node, Express e React com a biblioteca \n                <a onClick={() => newTab('https://socket.io/get-started/chat/')}> socket.io </a> tanto no Client-Side\n                quanto no Server-side. O backend e o frontend são relativamente simples, como podemos ver abaixo:\n                </ProjectDescription>\n\n            <ProjectContainer>\n                <CodeBlock>\n                    <h3>Backend NodeJS</h3>\n\n                    <code className=\"language-javascript\">\n                        {\n                            `const express = require('express');\nconst http = require('http');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = require('socket.io').listen(server);\n\nlet messageId = 0;\n\nio.on('connection', socket => {\n    console.log('Socket conectado ' + socket.id);\n\n    socket.on('sendMessage', data => {\n        data.id = messageId++;\n        socket.broadcast.emit('recivedMessage', data);\n        console.log(data);\n    });\n});\n\nserver.listen(process.env.PORT || 3333);`\n                        } </code>\n\n                </CodeBlock>\n                <img src={screenshotDark} />\n                {/* <img src={screenshotLight} /> */}\n            </ProjectContainer>\n\n            <ProjectDescription>\n                A comunicação do frontend com o backend é feito com o\n                    <a onClick={() => newTab('https://www.npmjs.com/package/socket.io-client')}> socket.io-client </a>\n                através de um script de poucas linhas:\n            </ProjectDescription>\n\n            <ProjectContainer>\n                <CodeBlock>\n                    <h3>Script socket.js (ReactJS)</h3>\n\n                    <code className=\"language-javascript\">\n                        {\n                            `import io from \"socket.io-client\";\n\nconst socket = io(process.env.REACT_APP_CHATAPP || 'https://BACKEND-URL.com', {});\nsocket.on('connect', () => { console.log('[IO] Connect => Connection established') });\n\nexport default socket;`\n                        } </code>\n\n                </CodeBlock>\n            </ProjectContainer>\n\n            <ProjectDescription>\n                Para enviar as mensagens, temos na função handleSubmit o socket.emit() que é usado para enviar promises\n                para o backend. Essa função recebe dois parâmetros, o nome da promise e o objeto JSON a ser enviado.\n            </ProjectDescription>\n\n            <ProjectContainer>\n                <CodeBlock>\n                    <h3>Componente principal (ReactJS)</h3>\n\n                    <code className=\"language-javascript\">\n                        {\n                            `import React, { useState, useEffect, useRef, useMemo } from 'react';\n\nimport socket from \"../../../../services/socket\";\n\nfunction Chat() {\n    const [messages, setMessages] = useState([]);\n    const [recivedMessage, setRecivedMessage] = useState(null);\n    \n    const messageText = useRef();\n    const username = useRef();\n\n    useMemo(() => { \n        socket.on('recivedMessage', message => {\n            message.from = 'other';\n            setRecivedMessage(message);\n            console.log(message);\n        })\n    }, []);\n\n    useEffect(()=> {\n        if(recivedMessage) setMessages([...messages, recivedMessage]);\n    },[recivedMessage]);\n\n    function handleSubmit(event) {\n        event.preventDefault();\n\n        const date = new Date().toTimeString().replace(/.*(\\d{2}:\\d{2}:\\d{2}).*/, \"$1\");;\n\n        const newMessage = {\n            from: 'my',\n            id: 0,\n            username: username.current.value,\n            messageText: messageText.current.value,\n            date,\n        }\n\n        setMessages([...messages, newMessage]);\n\n        socket.emit('sendMessage', newMessage);\n\n        messageText.current.value = '';\n    }\n\n    return (\n        ...\n    );\n}\n\nexport default Chat;`\n                        } </code>\n\n                </CodeBlock>\n            </ProjectContainer>\n\n            <ProjectDescription>\n                Agora para receber uma mensagem do backend temos a a função socket.on() que ficará\n                \"escultando\" o servidor até ele enviar uma promise do tipo 'recivedMessage' no nosso caso. O uso do\n                useMemo em conjunto com o useEffect foi uma solução que encontrei para corrigir um problema\n                estranho que tive, esse problema pode ser visto no seguinte\n                <a onClick={() => newTab('https://youtu.be/5427pRmQ8Oo')}> vídeo</a>.\n            </ProjectDescription>\n\n            <ProjectDescription>\n                O código completo pode ser encontrado no meu repositório do github\n                    <a onClick={() => newTab('https://github.com/obraia')}> clicando aqui</a>.\n            </ProjectDescription>\n\n        </Project>\n    );\n}\n\nexport default ChatDescription;"]},"metadata":{},"sourceType":"module"}